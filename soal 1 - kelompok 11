import math

def dist(p1, p2):
    return math.sqrt(((p2[1]-p1[1])**2)+((p2[0]-p1[0])**2))

def closest_brute_force(points):
    min_dist = float("inf")
    closest_pairs = []
    for i in range(len(points)):
        for j in range(i+1, len(points)):
            d = dist(points[i], points[j])
            if d < min_dist:
                min_dist = d
                closest_pairs = [(points[i], points[j])]
            elif d == min_dist:
                closest_pairs.append((points[i], points[j]))
    return closest_pairs, min_dist

def rec(xsorted, ysorted):
    n = len(xsorted)
    if n <= 3:
        return closest_brute_force(xsorted)
    else:
        midpoint = xsorted[n//2]
        xsorted_left = xsorted[:n//2]
        xsorted_right = xsorted[n//2:]
        ysorted_left = []
        ysorted_right = []
        for point in ysorted:
            ysorted_left.append(point) if (point[0] <= midpoint[0]) else ysorted_right.append(point)
        
        closest_pairs_left, delta_left = rec(xsorted_left, ysorted_left)
        closest_pairs_right, delta_right = rec(xsorted_right, ysorted_right)
        
        if delta_left < delta_right:
            closest_pairs, delta = closest_pairs_left, delta_left
        elif delta_right < delta_left:
            closest_pairs, delta = closest_pairs_right, delta_right
        else:
            closest_pairs = closest_pairs_left + closest_pairs_right
            delta = delta_left
        
        in_band = [point for point in ysorted if midpoint[0]-delta < point[0] < midpoint[0]+delta]
        for i in range(len(in_band)):
            for j in range(i+1, min(i+7, len(in_band))):
                d = dist(in_band[i], in_band[j])
                if d < delta:
                    closest_pairs = [(in_band[i], in_band[j])]
                    delta = d
                elif d == delta:
                    closest_pairs.append((in_band[i], in_band[j]))
        
        return closest_pairs, delta

def closest(points):
    xsorted = sorted(points, key=lambda point: point[0])
    ysorted = sorted(points, key=lambda point: point[1])
    return rec(xsorted, ysorted)

# Test the function
points = [(0, 0), (1, 1), (2, 2), (3, 3), (0, 4), (4, 0)]
closest_pairs, min_distance = closest(points)
print(f"Minimum distance: {min_distance}")
print("Closest pairs:")
for pair in closest_pairs:
    print(pair)

#CHATGPT, yang O(1) konstan saja
# https://chatgpt.com/c/6704ac24-c8ec-8001-b385-a2203d3f2b94

def find_position(n, target):
    # untuk hitung layer/lapisan matriks:
    layer = 0
    # value awal pada lapisan:
    start_value = 1

    # untuk mencari lapisan yang memuat K (angka yang dicari)
    while True:
        # Hitung nilai max pada lapisan:
        max_value = start_value + (n - 1 - 2 * layer) * 4 - 1
        # -2 untuk menghindari ujung matriks, lalu dikali 4 karena ada 4 sisi, kemudian ditambah 4 ujung matriks

        if start_value <= target <= max_value: # untuk mendeteksi value yang dicari
            break

        # berganti ke lapisan selanjutnya:
        layer += 1
        start_value = max_value + 1

    # panjang sisi lapisan
    side_length = n - 1 - 2 * layer
    # Posisi (index) angka yang dicari dalam lapisan, mulai dari index 0
    offset = target - start_value

    # mencari baris dan kolom berdasarkan posisinya di lapisan (atas/bawah/kiri/kanan):
    if offset < side_length: # kalau K ada di sisi atas:
        row = layer
        col = layer + offset
    elif offset < 2 * side_length: # kalau K ada di sisi kanan:
        row = layer + (offset - side_length)
        col = n - 1 - layer
    elif offset < 3 * side_length: # kalau K ada di sisi bawah:
        row = n - 1 - layer
        col = n - 1 - layer - (offset - 2 * side_length)
    else: # selain itu, kalau K ada di sisi kiri:
        row = n - 1 - layer - (offset - 3 * side_length)
        col = layer

    return row, col


# MAIN
N = int(input("N = "))
K = int(input("K = "))
row, col = find_position(N, K)
print("="*10)
print(f"R = {row}")
print(f"C = {col}")

# “Di hadapan TUHAN yang hidup, saya menegaskan bahwa saya tidak memberikan maupun menerima bantuan apa pun—baik lisan, tulisan,
# maupun elektronik—di dalam ujian ini selain daripada apa yang telah diizinkan oleh pengajar, dan tidak akan menyebarkan baik soal
# maupun jawaban ujian kepada pihak lain.”

# Naftali, Devlin, Matthew Layadi, Makarios


# “Di hadapan TUHAN yang hidup, saya menegaskan bahwa saya tidak memberikan maupun menerima bantuan apa pun—baik lisan, tulisan,
# maupun elektronik—di dalam ujian ini selain daripada apa yang telah diizinkan oleh pengajar, dan tidak akan menyebarkan baik soal
# maupun jawaban ujian kepada pihak lain.”

# Naftali, Devlin, Matthew Layadi, Makarios
